<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Phaser - Making your first game, part 1</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update, render: render });
//Game is called outside of the functions and thus global, so can be called in EVERY function//

function preload() {
    game.load.image('background', 'assets/background.png');
    game.load.image('platyellow', 'assets/platform_yellow_small.png');
    game.load.image('platpurple', 'assets/platform_purple_small.png');
    game.load.image('platred',    'assets/platform_red_small.png');
    game.load.spritesheet('hero',    'assets/hero_spritesheet.png', 200, 200);
    game.load.spritesheet('love',    'assets/love_spritesheet.png', 200, 200);
    game.load.spritesheet('dream',   'assets/dream_spritesheet.png', 200, 200);
    game.load.spritesheet('explore', 'assets/explore_spritesheet.png', 200, 200);
    game.load.spritesheet('fight',   'assets/fight_spritesheet.png', 200, 200);
    game.load.spritesheet('friend',  'assets/friend_spritesheet.png', 200, 200);
    game.load.spritesheet('home',    'assets/home_spritesheet.png', 200, 200);
    game.load.spritesheet('war',     'assets/war_spritesheet.png', 200, 200);
    game.load.spritesheet('villain', 'assets/villain_spritesheet.png', 200, 200);
    game.load.spritesheet('talk',    'assets/talk_spritesheet.png', 200, 200 );
    game.load.spritesheet('eyeball', 'assets/sprite_sheet_maincharacter.png', 200, 200);
}


var timer;
var total = 300;
var player; //Why define here? b/c these variables will be called in multiple functions!//
var platforms;
var cursors;
var collectibles;
var hero;
var love;
var dream;
var explore;
var fight;
var friend;
var home;
var war;
var villain;
var talk;
var score = 0;
var scoreText;
var timerText;


function create() {
    
    //Make the world Larger than the actual canvas!//
    game.world.setBounds(0, 0, 5000, 1200);

    //  We're going to be using physics, so enable the Arcade Physics system
    game.physics.startSystem(Phaser.Physics.ARCADE);/*global Phaser*/

    //  A simple background for our game
    var sky = game.add.sprite(0, 0, 'background');//Animated backgrounds? Note: sprites can be scaled like objects in group can be, but only if you set a variable as the sprite first//

    //sky.scale.setTo(1, 1);

    //  The platforms group contains the ground and the 2 ledges we can jump on
    platforms = game.add.group();

    //  We will enable physics for any object that is created in this group
    platforms.enableBody = true;//Makes the platforms have a 'body' so collisions happen//

    for (var i = 0; i < 17; i++)
    {
        var ground = platforms.create(i * 300, game.world.height - 50, 'platpurple');
        ground.body.immovable = true;
    }


    //  Now let's create two ledges
    var ledge = platforms.create(400, 950, 'platred');//Create thing in platform group, set height and how far to the right//
    ledge.body.immovable = true;

    ledge = platforms.create(-150, 800, 'platyellow');//This does start the x value of the object off of the screen to the left (b/c 0 is the far left of the screen.)//
    ledge.body.immovable = true;

        // The player and its settings
    player = game.add.sprite(32, game.world.height - 150, 'eyeball');
    player.anchor.setTo(0.5, 0.5);
    player.scale.x = 0.5;
    player.scale.y = 0.5;

    game.camera.follow(player);
    
    hero = game.add.sprite(400, game.world.height - 400, 'hero');
    hero.scale.x = 0.5;
    hero.scale.y = 0.5;

    love = game.add.sprite(600, game.world.height - 400, 'love');
    love.scale.x = 0.5;
    love.scale.y = 0.5;
    
    dream = game.add.sprite(800, game.world.height - 400, 'dream');
    dream.scale.x = 0.5;
    dream.scale.y = 0.5;
    
    explore = game.add.sprite(1000, game.world.height - 400, 'explore');
    explore.scale.x = 0.5;
    explore.scale.y = 0.5;
    
    home = game.add.sprite(1200, game.world.height - 400, 'home');
    home.scale.x = 0.5;
    home.scale.y = 0.5;
    
    war = game.add.sprite(1400, game.world.height - 400, 'war');
    war.scale.x = 0.5;
    war.scale.y = 0.5;
    
    fight = game.add.sprite(1600, game.world.height - 400, 'fight');
    fight.scale.x = 0.5;
    fight.scale.y = 0.5;
    
    villain = game.add.sprite(1800, game.world.height - 400, 'villain');
    villain.scale.x = 0.5;
    villain.scale.y = 0.5;

    talk = game.add.sprite(2000, game.world.height - 400, 'talk');
    talk.scale.x = 0.5;
    talk.scale.y = 0.5;
    
    friend = game.add.sprite(2200, game.world.height - 400, 'friend');
    friend.scale.x = 0.5;
    friend.scale.y = 0.5;

    //  We need to enable physics on the player
    game.physics.arcade.enable(player); //same kind of physics as on platform (don't want player to fall thru things and stuff)//
    game.physics.arcade.enable(hero);

    player.body.setSize(100, 180);//Width then height then 

    //  Player physics properties. Give the little guy a slight bounce.
    player.body.gravity.y = 300; //higher number is like heavier gravity they will fall harder//
    player.body.collideWorldBounds = true;//means they don't run off of the ends of the screen on left right top or bottom or world if we had a bigger screen w/ a camera//

    //  Our two animations, walking left and right.
    player.animations.add('walk', [42, 43, 44, 45, 46, 47, 48, 49], 12, true);//true means whether the animation loops or not in this case. the array of numbers is the frame order in the sprite sheet. this sprite sheet is 0->8 left to right//
    player.animations.add('jump', [0, 1, 2, 3, 4], 8, true);
    player.animations.add('jumpleft', [5, 6, 7, 8], 12, true);
    player.animations.add('fall', [9, 10, 11, 10], 12, true);
    player.animations.add('land', [12, 13, 14, 15, 16, 17, 18, 19, 20, 21], 12, true);
    player.animations.add('idle', [22, 23, 24, 25, 26, 25, 24, 23, 22, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 36, 35, 34, 33], 12, true);
    player.animations.add('read', [0, 50, 51, 52, 53, 54, 55, 56, 57, 52], 12, true);
    
    hero.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    love.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    home.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    friend.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    fight.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    dream.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    villain.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    war.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    explore.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    talk.animations.add('bounce', [0,1,2,3,4,5], 5, true);
    
    cursors = game.input.keyboard.createCursorKeys();//We created the cursors object, which means the player can be controlled with keyboard input.//

    //  Finally some stars to collect
    collectibles = game.add.group();

    //  We will enable physics for any star that is created in this group
    collectibles.enableBody = true;

    //  Create our Timer
    timer = game.time.create(false);
    //  Set a TimerEvent to occur after 1 seconds
    timer.loop(1000, updateCounter, this);
    //  Start the timer running - this is important!
    //  It won't start automatically, allowing you to hook it to button events and the like.
    timer.start();

    scoreText = game.add.text(16, 16, 'WORDS COLLECTED: 0/10', { fontSize: '32px', fill: '#FFFFFF' });//POINTS, x,y is 16,16, then default score and then size and hex color//
    scoreText.fixedToCamera = true;

    timerText = game.add.text(450, 16, 'GOOD NIGHT IN: 300', { fontSize: '32px', fill: '#FFFFFF' });//POINTS, x,y is 16,16, then default score and then size and hex color//
    timerText.fixedToCamera = true;
    
}

function update() {
    //  Collide the player and the stars with the platforms
    game.physics.arcade.collide(player, platforms);
    game.physics.arcade.collide(collectibles, platforms);//Also collides w/ platforms, meaning they do not sink into the ground//

      //  Reset the players velocity (movement)
    player.body.velocity.x = 0;//This means that when the character is receiving no input they have no velocity, ie, they are idle//

    if (cursors.left.isDown && player.body.velocity.y > -5 && player.body.velocity.y < 5)//if the left motion key is being held down, then the following is true//
    {
        //  Move to the left
        player.body.velocity.x = -150;//Movin' left at the speed of 150, that's the player's max running speed; question for later how do we handle character accelerate to max? Danny: some people will make a constant elsewhere and call the constant to the game, ie player's max velocity is blah (the constant) so it can be changed as needed by editing only one source. In this case the velocity would not be -150 but would be the name of the variable for player velocity. This way it can change dynamically based on player input. (But like double tap to dash, etc? later)//

        player.animations.play('walk');
    
        player.scale.x = -0.5;
    }
    else if (cursors.right.isDown && player.body.velocity.y > -5 && player.body.velocity.y < 5)//Because of the way this code is written, for example, Crypt of the Necrodancer would be unviable b/c Left takes priority (IF first, THEN ElseIf, THEN Else) so functionality like pressing both keys at once would be fucked up//
    {
        //  Move to the right
        player.body.velocity.x = 150;//Basically, this works but it's the least efficient way to accomplish natural motion, unless moving left as a priority over right and not moving is like a gameplay mechanic-- hierarchical issues are not going to work with this.//

        player.animations.play('walk');
        player.scale.x = 0.5;
    }
    else
    {

        if (player.body.velocity.y < -5)
        {
            
            if (cursors.left.isDown)
            {
                player.body.velocity.x = -150;
                player.animations.play('jumpleft');
                player.scale.x = 0.5;
            }
            else if (cursors.right.isDown)
            {
                player.body.velocity.x = 150;
                player.animations.play('jumpleft');
                player.scale.x = -0.5;
            }
            else
            {
                player.animations.play('jumpleft');                
            }
            

        }
        else if(player.body.velocity.y > 5)
        {
            player.animations.play('fall');

            if (cursors.left.isDown)
            {
                player.body.velocity.x = -150;
                player.scale.x = -0.5;
            }
            else if (cursors.right.isDown)
            {
                player.body.velocity.x = 150;
                player.scale.x = 0.5;
            }
        }
        else 
        {
            player.animations.play('idle');
        }
    }
    
    
    //  Allow the player to jump if they are touching the ground.
    if (cursors.up.isDown && player.body.touching.down)//Meaning that when the up key is pressed down AND the player is touching something-- player cannot jump on air, it won't work. If remove everything after the && then infinite jumping would be possible.//
    {
        player.body.velocity.y = -400;//Height of jump arc. negative means up and positive means down on the y axis. Number is magnitude of the jump.//
    }

    game.physics.arcade.overlap(player, hero, collectItem, null, this);
    game.physics.arcade.overlap(player, home, collectItem, null, this);
    game.physics.arcade.overlap(player, talk, collectItem, null, this);
    game.physics.arcade.overlap(player, love, collectItem, null, this);
    game.physics.arcade.overlap(player, war, collectItem, null, this);
    game.physics.arcade.overlap(player, friend, collectItem, null, this);
    game.physics.arcade.overlap(player, fight, collectItem, null, this);
    game.physics.arcade.overlap(player, villain, collectItem, null, this);
    game.physics.arcade.overlap(player, explore, collectItem, null, this);
    game.physics.arcade.overlap(player, dream, collectItem, null, this);
                                

    //****COLLECTIBLES!!!****//
    hero.animations.play('bounce');
    home.animations.play('bounce');
    love.animations.play('bounce');
    war.animations.play('bounce');
    dream.animations.play('bounce');
    talk.animations.play('bounce');
    friend.animations.play('bounce');
    fight.animations.play('bounce');
    explore.animations.play('bounce');
    villain.animations.play('bounce');        


}

function render () 
{
    //DEBUGGING - COMMENT IN TO USE//
    // game.debug.text(game.time.physicsElapsed, 32, 32);
    // game.debug.body(player);
    // game.debug.bodyInfo(player, 16, 24);

}

function collectItem (player, collectible) 
{
    
    // Removes the star from the screen
    collectible.kill();

    //  Add and update the score
    score += 1;
    scoreText.text = 'WORDS COLLECTED: ' + score + '/10';//Displays a string reading: [Text]: [Value of the score]//
}

function updateCounter() 
{

    total--;
    timerText.text = 'GOODNIGHT IN: ' + total;
    //Need a call to end level at total = 0//
}

</script>

</body>
</html>